export interface SiteGenieConfig {
  apiUrl: string;
  assistantId: string;
  companyId: string;
  userId: number;
  userName: string;
}

export interface ProcessQueryRequest {
  query: string;
  assistant_id: string;
  thread_id?: string;
  file_ids?: string[];
  company_id: string;
  user_id?: number;
  user_name?: string;
}

export interface StreamingResponse {
  data: string;
  error?: string;
  done?: boolean;
}

export class SiteGenieApiService {
  private config: SiteGenieConfig;
  private threadId: string | null = null;

  constructor(config: SiteGenieConfig) {
    this.config = config;
  }

  public getThreadId(): string | null {
    return this.threadId;
  }

  public setThreadId(threadId: string): void {
    this.threadId = threadId;
  }

  public async* processQuery(
    query: string,
    fileIds: string[] = []
  ): AsyncGenerator<StreamingResponse> {
    try {
      // Validate required configuration
      if (this.config.assistantId === 'your-assistant-id' ||
          this.config.companyId === 'your-company-id' ||
          !this.config.assistantId ||
          !this.config.companyId) {
        yield {
          data: '',
          error: 'API Configuration Required: Please configure your Assistant ID and Company ID in the settings.',
          done: true
        };
        return;
      }

      const requestBody: ProcessQueryRequest = {
        query,
        assistant_id: this.config.assistantId,
        company_id: this.config.companyId,
        file_ids: fileIds,
      };

      // Add thread_id if we have one, otherwise include user info for new thread creation
      if (this.threadId) {
        requestBody.thread_id = this.threadId;
      } else {
        requestBody.user_id = this.config.userId;
        requestBody.user_name = this.config.userName;
      }

      // Use Vercel proxy in production to avoid CORS issues
      const isProduction = window.location.hostname !== 'localhost';
      const apiUrl = isProduction
        ? '/api/proxy'
        : `${this.config.apiUrl}/process_query`;

      console.log('üîÑ API Request:', {
        url: apiUrl,
        method: 'POST',
        body: requestBody,
        threadId: this.threadId
      });

      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestBody),
      });

      console.log('üì° API Response Status:', response.status, response.statusText);
      console.log('üìã Response Headers:', Object.fromEntries(response.headers.entries()));

      // Check for thread_id in response headers
      const responseThreadId = response.headers.get('x-thread-id') || response.headers.get('thread-id');
      if (responseThreadId && !this.threadId) {
        console.log('üÜî Capturing thread_id from response:', responseThreadId);
        this.threadId = responseThreadId;
      }

      // Log 500 errors but continue processing since API still streams content
      if (response.status === 500) {
        console.warn('‚ö†Ô∏è API returned 500 status but will attempt to process stream anyway');
      }

      if (!response.body) {
        throw new Error('No response body');
      }
      const reader = response.body.getReader();
      const decoder = new TextDecoder();

      try {
        let fullResponse = '';
        console.log('üîÑ Starting to read stream...');

        while (true) {
          const { done, value } = await reader.read();

          if (done) {
            console.log('‚úÖ Stream completed. Full response (filtered):', fullResponse);
            console.log('üìä Stream stats: Total response length =', fullResponse.length);
            yield { data: '', done: true };
            break;
          }

          const chunk = decoder.decode(value, { stream: true });
          console.log('üì¶ Raw chunk received:', chunk);

          // Filter out HTML error pages and server error messages
          const isHtmlError = chunk.includes('<!doctype html>') ||
                             chunk.includes('<html') ||
                             chunk.includes('<title>500 Internal Server Error</title>') ||
                             chunk.includes('<h1>Internal Server Error</h1>') ||
                             chunk.includes('The server encountered an internal error and was unable to complete');

          const isErrorMessage = chunk.includes('Internal Server Error') ||
                                chunk.includes('generated by waitress') ||
                                chunk.includes('The server encountered an unexpected internal server error') ||
                                chunk.includes('500 Internal Server Error');

          if (isHtmlError || isErrorMessage) {
            console.warn('üö´ Filtering out HTML/server error from stream:', chunk.substring(0, 100) + '...');
            continue; // Skip this chunk, don't add to response
          }

          // Process chunks immediately - even single characters
          if (chunk) {
            fullResponse += chunk;
            console.log('‚ö° Yielding chunk immediately:', chunk);
            yield {
              data: chunk,
              done: false
            };
          }
        }
      } finally {
        reader.releaseLock();
      }
    } catch (error) {
      console.error('‚ùå Error processing query:', error);

      let errorMessage = 'Unknown error occurred';

      if (error instanceof TypeError && error.message === 'Failed to fetch') {
        console.error('üåê Network Error: Failed to fetch - likely CORS or connectivity issue');
        errorMessage = 'Network error: Unable to connect to the API. Check console for details.';
      } else if (error instanceof Error) {
        console.error('üö® Error details:', error.message);
        // Don't show 500 errors in chat since API still works
        if (error.message.includes('500') || error.message.includes('Internal Server Error')) {
          console.warn('üí° 500 error detected but API may still be functional - check stream output above');
          return; // Don't yield error, just return silently
        }
        errorMessage = error.message;
      }

      yield {
        data: '',
        error: errorMessage,
        done: true
      };
    }
  }

  public async uploadFile(file: File): Promise<string | null> {
    try {
      const formData = new FormData();
      formData.append('file', file);

      // Use Vercel proxy in production to avoid CORS issues
      const isProduction = window.location.hostname !== 'localhost';
      const uploadUrl = isProduction
        ? '/api/upload'
        : `${this.config.apiUrl}/upload`;

      const response = await fetch(uploadUrl, {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) {
        throw new Error(`Upload failed: ${response.status}`);
      }

      const result = await response.json();
      return result.file_id || null;
    } catch (error) {
      console.error('Error uploading file:', error);
      return null;
    }
  }

  public resetThread(): void {
    this.threadId = null;
  }
}

// Default configuration - can be overridden
export const defaultConfig: SiteGenieConfig = {
  apiUrl: 'https://flaskapi.sitegenie.ai',
  assistantId: 'your-assistant-id', // This should be configured
  companyId: 'your-company-id',     // This should be configured
  userId: 1,                        // This should be configured
  userName: 'User',                 // This should be configured
};

// Singleton instance
let apiService: SiteGenieApiService | null = null;

export const getSiteGenieApiService = (config?: SiteGenieConfig): SiteGenieApiService => {
  if (!apiService) {
    apiService = new SiteGenieApiService(config || defaultConfig);
  }
  return apiService;
};

export const initializeSiteGenieApi = (config: SiteGenieConfig): SiteGenieApiService => {
  apiService = new SiteGenieApiService(config);
  return apiService;
};